use crate::utils;
use blstrs::Scalar;
use ff::Field;
use std::sync::LazyLock;

fn parse_scalar(s: &str) -> Scalar {
    utils::parse_scalar(s).unwrap()
}

const R: usize = 3;
const C: usize = 1;
const T: usize = R + C;
const NUM_FULL_ROUNDS_START: usize = 4;
const NUM_FULL_ROUNDS_END: usize = 4;
const NUM_FULL_ROUNDS: usize = NUM_FULL_ROUNDS_START + NUM_FULL_ROUNDS_END;
const NUM_PARTIAL_ROUNDS: usize = 56;
const NUM_ROUNDS: usize = NUM_FULL_ROUNDS + NUM_PARTIAL_ROUNDS;

// The round constants and MDS matrix have been generated by the official script at
// https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage.
//
// The command line used was:
//
//   sage generate_parameters_grain.sage 1 0 255 4 8 56 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001

fn make_mds() -> [[Scalar; T]; T] {
    [
        [
            parse_scalar("0x298b7c2407511920d8e2f173fdf03c8c80d841a04def19fcfe701369758527dc"),
            parse_scalar("0x2c58f3708d5295f39bcf9803995ec4832e8fb6ff53b6621f7ca8b86f916bcb5c"),
            parse_scalar("0x5914b33fd35224fd55471ad751fc62b4d01db650734d8516dfbec88ab333893c"),
            parse_scalar("0x5c49e1934862d807904970e1a178b323cec2d0f7becdc1082ebd56a28193318d"),
        ],
        [
            parse_scalar("0x0145e8e03f232af259daf27a7bf6d87eef09ad0c6a5070c6529f86fa18f8cec5"),
            parse_scalar("0x4024abec6f929bfcf86216af1568a890d33803dec7e3c584942271a56b82ed74"),
            parse_scalar("0x39602b2f398221ff9fd51bef6f9bffefdf327c657471629e44f9ac0d3be2dcd7"),
            parse_scalar("0x4aeb8c69f52f416f5b4705b3a73a4a8edd8d681b3ba64ac91a76ad9b03a4f039"),
        ],
        [
            parse_scalar("0x2d86f821617e6763543bb9d8d5d6ce12f8f983aee87876ca82b3229cd0921da6"),
            parse_scalar("0x6b123db55b6972d0d81a3741ac42d704e14707d98f976fbbcf347b6e4d273cae"),
            parse_scalar("0x59c978e04431e87e06089bf64592992e8217006ee9bc5a7f4cdd9e9bede7087d"),
            parse_scalar("0x3632327f99c712c2a1dc345fd77ad7c8bdbe1cfc6de3aefdfc4579ff841d2c91"),
        ],
        [
            parse_scalar("0x469c003415373e6cb7df81d0937384f6717e951d1637a0d10347e4cdc4a887c3"),
            parse_scalar("0x29bea5c6b354f59988897aedef0ea53081c7a0a00fe174c94e7e12fd7841d1ad"),
            parse_scalar("0x67e972fdcdf41ab5ed8393284aae6906a682f63995f65eb471f87f55c71736e7"),
            parse_scalar("0x224fb6ad78d91f539e305b31be0dcf2f3ca958a21fa4b124da21f7ad7da939e8"),
        ],
    ]
}

static ROUND_CONSTANTS: LazyLock<[Scalar; NUM_ROUNDS * T]> = LazyLock::new(|| {
    let bytes = include_bytes!("../params/arc.bin");
    let mut constants = [Scalar::ZERO; NUM_ROUNDS * T];
    for i in 0..(NUM_ROUNDS * T) {
        constants[i] = Scalar::from_bytes_le(&bytes[(i * 32)..((i + 1) * 32)].try_into().unwrap())
            .into_option()
            .unwrap();
    }
    constants
});

static MDS_MATRIX: LazyLock<[[Scalar; T]; T]> = LazyLock::new(|| make_mds());

fn pow5(x: Scalar) -> Scalar {
    x.square().square() * x
}

fn round(state: &mut [Scalar; T], i: usize, full: bool) {
    let c = &ROUND_CONSTANTS;
    let mds = &*MDS_MATRIX;

    state[0] += c[i * T + 0];
    state[1] += c[i * T + 1];
    state[2] += c[i * T + 2];
    state[3] += c[i * T + 3];

    state[0] = pow5(state[0]);
    if full {
        state[1] = pow5(state[1]);
        state[2] = pow5(state[2]);
        state[3] = pow5(state[3]);
    }

    let mut new_state = [Scalar::ZERO; T];
    new_state[0] =
        mds[0][0] * state[0] + mds[0][1] * state[1] + mds[0][2] * state[2] + mds[0][3] * state[3];
    new_state[1] =
        mds[1][0] * state[0] + mds[1][1] * state[1] + mds[1][2] * state[2] + mds[1][3] * state[3];
    new_state[2] =
        mds[2][0] * state[0] + mds[2][1] * state[1] + mds[2][2] * state[2] + mds[2][3] * state[3];
    new_state[3] =
        mds[3][0] * state[0] + mds[3][1] * state[1] + mds[3][2] * state[2] + mds[3][3] * state[3];
    *state = new_state;
}

pub fn hash(inputs: &[Scalar]) -> Scalar {
    assert!(!inputs.is_empty());
    let mut state = [Scalar::ZERO; T];
    for chunk in inputs.chunks(3) {
        state[0] += chunk[0];
        if chunk.len() > 1 {
            state[1] += chunk[1];
        }
        if chunk.len() > 2 {
            state[2] += chunk[2];
        }
        for i in 0..NUM_ROUNDS {
            round(
                &mut state,
                i,
                /*full=*/
                i < NUM_FULL_ROUNDS_START || i >= NUM_FULL_ROUNDS_START + NUM_PARTIAL_ROUNDS,
            );
        }
    }
    state[0]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hash1() {
        assert_eq!(
            hash(&[42.into()]),
            parse_scalar("0x0531b2fa3c2aa794859d54c409ac6bf33a19981275bff625c5eeb8d1cc8d123c")
        );
    }

    #[test]
    fn test_hash2() {
        assert_eq!(
            hash(&[1.into(), 2.into()]),
            parse_scalar("0x520651bc5804254d3306d30c7e3242e00f527bb7f39aedb7f828e346299bd91c")
        );
    }

    #[test]
    fn test_hash3() {
        assert_eq!(
            hash(&[3.into(), 4.into(), 5.into()]),
            parse_scalar("0x1a9f84b2d90c7ec4efb7e8c38efddad5983245c1132434bb94c74d19eb04cb3a")
        );
    }

    #[test]
    fn test_hash4() {
        assert_eq!(
            hash(&[6.into(), 7.into(), 8.into(), 9.into()]),
            parse_scalar("0x5497afdc8bc505782b08a63601eec9fa0e4037e61d06f453edff9a8ca1991b76")
        );
    }
}
